# Rebase Plan: Aligning rusty-attachments with Python Snapshots Composable Operations

**Date:** 2026-01-10  
**Status:** PROPOSAL - Pending Review

## Executive Summary

This document proposes updates to align rusty-attachments with the new Python Snapshots composable operations design. The Python implementation introduces a clean separation of concerns with 10 composable operations (COLLECT, HASH, HASH_UPLOAD, DOWNLOAD, FILTER, DIFF, COMPOSE, SUBTREE, PARTITION, JOIN) and 4 manifest classes (Snapshot, SnapshotDiff, AbsSnapshot, AbsSnapshotDiff).

The current rusty-attachments design is fundamentally compatible but needs restructuring to match the composable API surface. Key changes involve:
1. **BREAKING**: Remove `V2025_12_04_beta` - replaced by `V2025_12` with new spec version strings
2. Separating COLLECT from HASH (currently combined in `FileSystemScanner::snapshot`)
3. Adding manifest type wrappers (Abs/Rel × Snapshot/Diff) with 4 new spec versions
4. Implementing missing operations (COMPOSE, SUBTREE, PARTITION, JOIN)
5. Aligning the `ContentAddressedDataCache` trait hierarchy

---

## 0. Manifest Format Changes (BREAKING)

### 0.1 Deprecated: `V2025_12_04_beta`

The `V2025_12_04_beta` manifest version **no longer exists in Python** and must be removed from rusty-attachments. It has been replaced by the `v2025-12` format with path-style and manifest-type encoded in the specification version string.

### 0.2 New Specification Versions (v2025-12)

The Python Snapshots library introduces 4 new specification version strings:

| Spec Version String | Path Style | Manifest Type | Rust Type |
|---------------------|------------|---------------|-----------|
| `absolute-manifest-snapshot-beta-2025-12` | Absolute | Snapshot | `AbsSnapshot` |
| `absolute-manifest-diff-beta-2025-12` | Absolute | Diff | `AbsSnapshotDiff` |
| `relative-manifest-snapshot-beta-2025-12` | Relative | Snapshot | `Snapshot` |
| `relative-manifest-diff-beta-2025-12` | Relative | Diff | `SnapshotDiff` |

### 0.3 ManifestFilePath Field Changes

| Field | Type | v2025-12 Semantics |
|-------|------|-------------------|
| `path` | `String` | POSIX format, `/` separator. Absolute or relative based on spec version. |
| `hash` | `Option<String>` | `None` for symlinks, chunked files, deleted entries, **or unhashed files** (new!) |
| `size` | `Option<u64>` | File size in bytes |
| `mtime` | `Option<i64>` | Modification time in **microseconds** since epoch |
| `runnable` | `bool` | POSIX execute bit |
| `chunkhashes` | `Option<Vec<String>>` | Chunk hashes for files > 256MB |
| `symlink_target` | `Option<String>` | Target path for symlinks |
| `deleted` | `bool` | Deletion marker for diff manifests |

**Key semantic change**: `hash=None` is now valid for files that have been collected but not yet hashed (COLLECT without HASH). Previously all non-symlink, non-chunked files required a hash.

### 0.4 ManifestDirectoryPath Fields

| Field | Type | Description |
|-------|------|-------------|
| `path` | `String` | Directory path (POSIX format) |
| `deleted` | `bool` | Deletion marker for diff manifests |

### 0.5 Constants

```rust
pub const DEFAULT_FILE_CHUNK_SIZE: u64 = 256 * 1024 * 1024; // 256MB
pub const WHOLE_FILE_CHUNK_SIZE: i64 = -1; // Sentinel for no chunking
```

### 0.6 Configurable Chunk Size

Python allows `file_chunk_size_bytes: Optional[int]` on `collect_manifest()` and `hash_manifest()`. Current Rust uses a hardcoded constant.

**Action:** Add `file_chunk_size_bytes: Option<u64>` to `CollectOptions` and `HashOptions`. Default to `DEFAULT_FILE_CHUNK_SIZE` when `None`.

---

## 1. Operation Mapping: Python → Rust

### 1.1 Current State Analysis

| Python Operation | Current Rust Name | New Rust Name | Status | Notes |
|-----------------|-------------------|---------------|--------|-------|
| `collect_manifest()` | `FileSystemScanner::snapshot_structure()` | `collect_manifest()` | ⚠️ RENAME+REFACTOR | Returns manifest with empty hashes, add symlink policy |
| `hash_manifest()` | None (combined with collect) | `hash_manifest()` | ❌ MISSING | Need standalone hash operation |
| `hash_upload_manifest()` | `UploadOrchestrator::upload_manifest_contents()` | `hash_upload_manifest()` | ⚠️ RENAME+REFACTOR | See section 4 for pipeline analysis |
| `download_manifest()` | `DownloadOrchestrator::download_manifest_contents()` | `download_manifest()` | ✅ RENAME | Good alignment, just rename |
| `filter_manifest()` | `GlobFilter` (at scan time) | `filter_manifest()` | ⚠️ REFACTOR | Move to post-operation filter |
| `compute_diff_manifest()` | `DiffEngine::diff()` | `compute_diff_manifest()` | ⚠️ REFACTOR | Add manifest→manifest comparison |
| `compose_manifests()` | `merge_manifests()` | `compose_manifests()` | ⚠️ RENAME+REFACTOR | Add trie-based composition with deletion markers |
| `subtree_manifest()` | None | `subtree_manifest()` | ❌ MISSING | Need to implement |
| `partition_manifest()` | None | `partition_manifest()` | ❌ MISSING | Need to implement |
| `join_manifest()` | None | `join_manifest()` | ❌ MISSING | Need to implement |

### 1.2 Naming Convention

Operations use the same terminology as Python but follow language-native conventions:

| Python | Rust | Notes |
|--------|------|-------|
| `collect_manifest()` | `collect_manifest()` | Both use snake_case |
| `hash_manifest()` | `hash_manifest()` | Both use snake_case |
| `hash_upload_manifest()` | `hash_upload_manifest()` | Both use snake_case |
| `download_manifest()` | `download_manifest()` | Both use snake_case |
| `filter_manifest()` | `filter_manifest()` | Both use snake_case |
| `compute_diff_manifest()` | `compute_diff_manifest()` | Both use snake_case |
| `compose_manifests()` | `compose_manifests()` | Both use snake_case |
| `subtree_manifest()` | `subtree_manifest()` | Both use snake_case |
| `partition_manifest()` | `partition_manifest()` | Both use snake_case |
| `join_manifest()` | `join_manifest()` | Both use snake_case |
| `IncludeExcludePathsFilter` | `IncludeExcludePathsFilter` | Both use PascalCase for types |
| `SymlinkPolicy` | `SymlinkPolicy` | Both use PascalCase for enums |

Rust and Python both use snake_case for functions, so names align naturally. Types use PascalCase in both.

Module structure: `crates/model/src/operations/{operation}.rs`

### 1.2 Proposed Rust Operations

```rust
// crates/model/src/operations/mod.rs (NEW MODULE)

pub mod collect;    // COLLECT operation
pub mod hash;       // HASH operation  
pub mod filter;     // FILTER operation
pub mod diff;       // DIFF operation (manifest-to-manifest)
pub mod compose;    // COMPOSE operation
pub mod subtree;    // SUBTREE operation
pub mod partition;  // PARTITION operation
pub mod join;       // JOIN operation

// Re-exports
pub use collect::collect_manifest;
pub use hash::hash_manifest;
pub use filter::{filter_manifest, IncludeExcludePathsFilter};
pub use diff::compute_diff_manifest;
pub use compose::compose_manifests;
pub use subtree::subtree_manifest;
pub use partition::partition_manifest;
pub use join::join_manifest;
```

---

## 2. Manifest Class Hierarchy

### 2.1 Python Design

```
Snapshot        - Relative-path snapshot (portable format)
SnapshotDiff    - Relative-path diff between snapshots
AbsSnapshot     - Absolute-path snapshot (for filesystem operations)
AbsSnapshotDiff - Absolute-path diff (for applying changes)
```

Type aliases:
```python
RelManifest = Union[Snapshot, SnapshotDiff]      # Any relative-path manifest
AbsManifest = Union[AbsSnapshot, AbsSnapshotDiff] # Any absolute-path manifest
AnySnapshot = Union[AbsSnapshot, Snapshot]        # Any snapshot
AnyDiff = Union[AbsSnapshotDiff, SnapshotDiff]    # Any diff
AnyManifest = Union[...]                          # All four types
```

### 2.2 Current Rust Design (TO BE REMOVED)

```rust
// DEPRECATED - Remove this
pub enum Manifest {
    V2023_03_03(v2023_03_03::AssetManifest),
    V2025_12_04_beta(v2025_12_04::AssetManifest),  // ❌ REMOVE - no longer in Python
}
```

The `V2025_12_04_beta` variant **must be removed**. The Python code has moved to `v2025-12` format with path-style and manifest-type encoded in the spec version string.

### 2.3 Proposed Rust Design

**Step 1: Update ManifestVersion enum**

```rust
// crates/model/src/version.rs

/// Manifest format version.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum ManifestVersion {
    /// Legacy format (2023-03-03): files only, no directories/symlinks/chunking
    V2023_03_03,
    /// Current format (2025-12): directories, symlinks, chunking, diff support
    V2025_12,
}

/// Path style for v2025-12 manifests.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub enum PathStyle {
    /// Paths are absolute filesystem paths (e.g., `/home/user/project/file.txt`)
    Absolute,
    /// Paths are relative to manifest root (e.g., `project/file.txt`)
    #[default]
    Relative,
}

/// Manifest type (snapshot vs diff).
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub enum ManifestType {
    /// Full snapshot - all files present
    #[default]
    Snapshot,
    /// Diff against parent - only changes
    Diff,
}

/// Combined specification version for v2025-12 format.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct SpecVersion {
    pub path_style: PathStyle,
    pub manifest_type: ManifestType,
}

impl SpecVersion {
    pub const ABS_SNAPSHOT: Self = Self { 
        path_style: PathStyle::Absolute, 
        manifest_type: ManifestType::Snapshot 
    };
    pub const ABS_DIFF: Self = Self { 
        path_style: PathStyle::Absolute, 
        manifest_type: ManifestType::Diff 
    };
    pub const REL_SNAPSHOT: Self = Self { 
        path_style: PathStyle::Relative, 
        manifest_type: ManifestType::Snapshot 
    };
    pub const REL_DIFF: Self = Self { 
        path_style: PathStyle::Relative, 
        manifest_type: ManifestType::Diff 
    };
    
    /// Get the specification version string for JSON encoding.
    pub fn spec_string(&self) -> &'static str {
        match (self.path_style, self.manifest_type) {
            (PathStyle::Absolute, ManifestType::Snapshot) => "absolute-manifest-snapshot-beta-2025-12",
            (PathStyle::Absolute, ManifestType::Diff) => "absolute-manifest-diff-beta-2025-12",
            (PathStyle::Relative, ManifestType::Snapshot) => "relative-manifest-snapshot-beta-2025-12",
            (PathStyle::Relative, ManifestType::Diff) => "relative-manifest-diff-beta-2025-12",
        }
    }
    
    /// Parse specification version string.
    pub fn from_spec_string(s: &str) -> Option<Self> {
        match s {
            "absolute-manifest-snapshot-beta-2025-12" => Some(Self::ABS_SNAPSHOT),
            "absolute-manifest-diff-beta-2025-12" => Some(Self::ABS_DIFF),
            "relative-manifest-snapshot-beta-2025-12" => Some(Self::REL_SNAPSHOT),
            "relative-manifest-diff-beta-2025-12" => Some(Self::REL_DIFF),
            _ => None,
        }
    }
}
```

**Step 2: Update Manifest enum**

```rust
// crates/model/src/lib.rs

/// Version-agnostic manifest wrapper.
#[derive(Debug, Clone)]
pub enum Manifest {
    /// Legacy v2023-03-03 format
    V2023_03_03(v2023_03_03::AssetManifest),
    /// Current v2025-12 format with spec version metadata
    V2025_12 {
        manifest: v2025_12::AssetManifest,
        spec: SpecVersion,
    },
}
```

**Step 3: Add newtype wrappers for type safety**

```rust
// crates/model/src/manifest_types.rs (NEW)

use crate::{Manifest, SpecVersion, PathStyle, ManifestType};

/// Relative-path snapshot manifest.
/// Spec: `relative-manifest-snapshot-beta-2025-12`
#[derive(Debug, Clone)]
pub struct Snapshot(pub(crate) Manifest);

impl Snapshot {
    /// Create from manifest, validating constraints.
    pub fn try_from(manifest: Manifest) -> Result<Self, ManifestTypeError> {
        validate_spec(&manifest, PathStyle::Relative, ManifestType::Snapshot)?;
        Ok(Self(manifest))
    }
    
    /// Convert to absolute paths by prepending a root.
    pub fn to_absolute(self, root: &Path) -> AbsSnapshot {
        // Prepend root to all paths
        AbsSnapshot(transform_paths(self.0, |p| format!("{}/{}", root.display(), p)))
    }
    
    /// Access inner manifest.
    pub fn inner(&self) -> &Manifest { &self.0 }
    
    /// Consume and return inner manifest.
    pub fn into_inner(self) -> Manifest { self.0 }
}

/// Relative-path diff manifest.
/// Spec: `relative-manifest-diff-beta-2025-12`
#[derive(Debug, Clone)]
pub struct SnapshotDiff(pub(crate) Manifest);

impl SnapshotDiff {
    pub fn try_from(manifest: Manifest) -> Result<Self, ManifestTypeError> {
        validate_spec(&manifest, PathStyle::Relative, ManifestType::Diff)?;
        Ok(Self(manifest))
    }
    
    /// Get parent manifest hash (required for diff manifests).
    pub fn parent_hash(&self) -> &str {
        // Diff manifests must have parent_manifest_hash
        match &self.0 {
            Manifest::V2025_12 { manifest, .. } => {
                manifest.parent_manifest_hash.as_deref().unwrap()
            }
            _ => unreachable!("SnapshotDiff only wraps V2025_12"),
        }
    }
}

/// Absolute-path snapshot manifest.
/// Spec: `absolute-manifest-snapshot-beta-2025-12`
#[derive(Debug, Clone)]
pub struct AbsSnapshot(pub(crate) Manifest);

impl AbsSnapshot {
    pub fn try_from(manifest: Manifest) -> Result<Self, ManifestTypeError> {
        validate_spec(&manifest, PathStyle::Absolute, ManifestType::Snapshot)?;
        Ok(Self(manifest))
    }
    
    /// Extract subtree as relative manifest.
    pub fn subtree(&self, prefix: &str, symlink_policy: SymlinkPolicy) -> Snapshot {
        subtree_manifest(self, prefix, symlink_policy)
    }
    
    /// Partition into multiple (root, Snapshot) pairs.
    pub fn partition(&self, roots: Option<&[String]>) -> Vec<(String, Snapshot)> {
        partition_manifest(self, roots, None, SymlinkPolicy::default())
    }
}

/// Absolute-path diff manifest.
/// Spec: `absolute-manifest-diff-beta-2025-12`
#[derive(Debug, Clone)]
pub struct AbsSnapshotDiff(pub(crate) Manifest);

impl AbsSnapshotDiff {
    pub fn try_from(manifest: Manifest) -> Result<Self, ManifestTypeError> {
        validate_spec(&manifest, PathStyle::Absolute, ManifestType::Diff)?;
        Ok(Self(manifest))
    }
}

// Type aliases matching Python
pub type RelManifest = Either<Snapshot, SnapshotDiff>;
pub type AbsManifest = Either<AbsSnapshot, AbsSnapshotDiff>;
pub type AnySnapshot = Either<AbsSnapshot, Snapshot>;
pub type AnyDiff = Either<AbsSnapshotDiff, SnapshotDiff>;

/// Error when manifest doesn't match expected type.
#[derive(Debug, Clone, thiserror::Error)]
pub enum ManifestTypeError {
    #[error("Expected {expected_path_style:?} paths, got {actual_path_style:?}")]
    PathStyleMismatch {
        expected_path_style: PathStyle,
        actual_path_style: PathStyle,
    },
    #[error("Expected {expected_type:?} manifest, got {actual_type:?}")]
    TypeMismatch {
        expected_type: ManifestType,
        actual_type: ManifestType,
    },
    #[error("V2023_03_03 manifests cannot be converted to typed wrappers")]
    LegacyVersionNotSupported,
    #[error("Diff manifest missing parent_manifest_hash")]
    MissingParentHash,
}
```

// Type aliases matching Python
pub type RelManifest = Either<Snapshot, SnapshotDiff>;
pub type AbsManifest = Either<AbsSnapshot, AbsSnapshotDiff>;
pub type AnySnapshot = Either<AbsSnapshot, Snapshot>;
pub type AnyDiff = Either<AbsSnapshotDiff, SnapshotDiff>;
pub type AnyManifest = Either4<Snapshot, SnapshotDiff, AbsSnapshot, AbsSnapshotDiff>;

impl Snapshot {
    /// Create from manifest, validating it's a relative-path snapshot.
    pub fn try_from(manifest: Manifest) -> Result<Self, ManifestTypeError> {
        validate_relative_paths(&manifest)?;
        validate_snapshot_type(&manifest)?;
        Ok(Self(manifest))
    }
    
    /// Convert to absolute paths by prepending a root.
    pub fn to_absolute(self, root: &Path) -> AbsSnapshot {
        // Implementation
    }
}

impl AbsSnapshot {
    /// Create from manifest, validating it's an absolute-path snapshot.
    pub fn try_from(manifest: Manifest) -> Result<Self, ManifestTypeError> {
        validate_absolute_paths(&manifest)?;
        validate_snapshot_type(&manifest)?;
        Ok(Self(manifest))
    }
    
    /// Extract subtree as relative manifest.
    pub fn subtree(&self, prefix: &str) -> Snapshot {
        // Implementation
    }
}
```

**Rationale:**
- Type safety at API boundaries - operations return/accept specific manifest types
- Inner `Manifest` still accessible for serialization
- Follows Rust newtype pattern
- Clear mapping to Python types
- Compile-time enforcement of path-style and manifest-type constraints

---

## 3. ContentAddressedDataCache Trait

### 3.1 Python Design

```python
@dataclass
class ContentAddressedDataCache(ABC):
    @abstractmethod
    def get_object_key(self, hash_value: str, algorithm: str) -> str: ...
    @abstractmethod
    def object_exists(self, hash_value: str, algorithm: str) -> bool: ...

@dataclass
class S3DataCache(ContentAddressedDataCache):
    s3_bucket: str
    s3_key_prefix: str
    s3_client: Any
    s3_check_cache: Optional[S3CheckCache] = None

@dataclass  
class FileSystemDataCache(ContentAddressedDataCache):
    root_path: Path
```

### 3.2 Current Rust Design

```rust
// crates/storage/src/traits.rs
#[async_trait]
pub trait StorageClient: Send + Sync {
    async fn head_object(&self, bucket: &str, key: &str) -> Result<Option<u64>, StorageError>;
    async fn put_object(...) -> Result<(), StorageError>;
    async fn get_object(...) -> Result<Vec<u8>, StorageError>;
    // ... more S3-specific methods
}
```

The current `StorageClient` is S3-specific. We need a higher-level abstraction.

### 3.3 Proposed Rust Design

```rust
// crates/storage/src/data_cache.rs (NEW)

use async_trait::async_trait;
use rusty_attachments_model::HashAlgorithm;

/// Content-addressable data cache abstraction.
/// 
/// Provides a unified interface for storing and retrieving content
/// by hash, regardless of the underlying storage backend.
#[async_trait]
pub trait ContentAddressedDataCache: Send + Sync {
    /// Get the storage key for a given hash.
    fn get_object_key(&self, hash: &str, algorithm: HashAlgorithm) -> String;
    
    /// Check if an object exists in the cache.
    async fn object_exists(&self, hash: &str, algorithm: HashAlgorithm) -> Result<bool, StorageError>;
    
    /// Get object size if it exists.
    async fn object_size(&self, hash: &str, algorithm: HashAlgorithm) -> Result<Option<u64>, StorageError>;
    
    /// Upload content to the cache.
    async fn put_object(
        &self,
        hash: &str,
        algorithm: HashAlgorithm,
        data: &[u8],
    ) -> Result<(), StorageError>;
    
    /// Upload content from a file.
    async fn put_object_from_file(
        &self,
        hash: &str,
        algorithm: HashAlgorithm,
        file_path: &Path,
        progress: Option<&dyn ProgressCallback<TransferProgress>>,
    ) -> Result<(), StorageError>;
    
    /// Download content from the cache.
    async fn get_object(
        &self,
        hash: &str,
        algorithm: HashAlgorithm,
    ) -> Result<Vec<u8>, StorageError>;
    
    /// Download content to a file.
    async fn get_object_to_file(
        &self,
        hash: &str,
        algorithm: HashAlgorithm,
        file_path: &Path,
        progress: Option<&dyn ProgressCallback<TransferProgress>>,
    ) -> Result<(), StorageError>;
}

/// S3-backed content-addressable data cache.
pub struct S3DataCache<C: StorageClient> {
    client: C,
    bucket: String,
    key_prefix: String,
    s3_check_cache: Option<S3CheckCache>,
}

impl<C: StorageClient> S3DataCache<C> {
    pub fn new(client: C, bucket: String, key_prefix: String) -> Self {
        Self {
            client,
            bucket,
            key_prefix,
            s3_check_cache: None,
        }
    }
    
    pub fn with_check_cache(mut self, cache: S3CheckCache) -> Self {
        self.s3_check_cache = Some(cache);
        self
    }
}

#[async_trait]
impl<C: StorageClient> ContentAddressedDataCache for S3DataCache<C> {
    fn get_object_key(&self, hash: &str, algorithm: HashAlgorithm) -> String {
        format!("{}/{}.{}", self.key_prefix, hash, algorithm.extension())
    }
    
    async fn object_exists(&self, hash: &str, algorithm: HashAlgorithm) -> Result<bool, StorageError> {
        let key = self.get_object_key(hash, algorithm);
        
        // Check local cache first
        if let Some(ref cache) = self.s3_check_cache {
            if cache.exists(&self.bucket, &key)? {
                return Ok(true);
            }
        }
        
        // Check S3
        let exists = self.client.head_object(&self.bucket, &key).await?.is_some();
        
        // Update cache
        if exists {
            if let Some(ref cache) = self.s3_check_cache {
                cache.mark_exists(&self.bucket, &key)?;
            }
        }
        
        Ok(exists)
    }
    
    // ... other implementations
}

/// Local filesystem content-addressable data cache.
/// 
/// Stores content in a directory structure: `{root_path}/{hash}.{algorithm}`
pub struct FileSystemDataCache {
    root_path: PathBuf,
}

impl FileSystemDataCache {
    pub fn new(root_path: PathBuf) -> Result<Self, StorageError> {
        if !root_path.is_absolute() {
            return Err(StorageError::InvalidPath {
                path: root_path.display().to_string(),
                reason: "FileSystemDataCache root must be absolute".into(),
            });
        }
        Ok(Self { root_path })
    }
}

#[async_trait]
impl ContentAddressedDataCache for FileSystemDataCache {
    fn get_object_key(&self, hash: &str, algorithm: HashAlgorithm) -> String {
        format!("{}.{}", hash, algorithm.extension())
    }
    
    async fn object_exists(&self, hash: &str, algorithm: HashAlgorithm) -> Result<bool, StorageError> {
        let path = self.root_path.join(self.get_object_key(hash, algorithm));
        Ok(path.exists())
    }
    
    // ... other implementations (sync wrapped in async for consistency)
}
```

---

## 4. Pipelined Hash+Upload: Rust Analysis

### 4.1 Python Design

The Python implementation uses a two-pool pipeline:
1. **READ+HASH pool**: Reads file chunks and computes hashes
2. **UPLOAD pool**: Uploads hashed chunks to S3

Memory is bounded via `_MemoryPool` with backpressure.

### 4.2 Does Rust Need This Pattern?

**Short answer: No, tokio already provides efficient pipelining.**

**Analysis:**

| Concern | Python Approach | Rust/Tokio Approach |
|---------|-----------------|---------------------|
| CPU-bound hashing | ThreadPoolExecutor | `tokio::task::spawn_blocking` or `rayon` |
| I/O-bound uploads | ThreadPoolExecutor | Native async with `tokio` runtime |
| Memory backpressure | Custom `_MemoryPool` | `tokio::sync::Semaphore` for permits |
| Pipeline coordination | Manual queue management | `tokio::sync::mpsc` channels or `futures::stream` |

**Why Python needs explicit pools:**
- Python's GIL prevents true parallelism for CPU work
- `asyncio` is single-threaded by default
- Explicit thread pools needed to escape GIL for hashing

**Why Rust doesn't need this complexity:**
- `tokio` work-stealing runtime handles task scheduling efficiently
- `spawn_blocking` moves CPU work off async threads automatically
- `rayon` provides parallel iterators for CPU-bound batch work
- No GIL - true parallelism without explicit pools

### 4.3 Recommended Rust Approach

```rust
// crates/storage/src/operations/hash_upload.rs

use futures::stream::{self, StreamExt};
use tokio::sync::Semaphore;

/// Hash files and upload to data cache.
/// 
/// Uses tokio's native concurrency - no explicit pipeline needed.
pub async fn hash_upload_manifest<C: ContentAddressedDataCache>(
    manifest: AbsManifest,
    data_cache: &C,
    options: HashUploadOptions,
    progress: Option<&dyn ProgressCallback<TransferProgress>>,
) -> Result<AbsManifest, StorageError> {
    // Memory permits for backpressure
    let memory_semaphore = Arc::new(Semaphore::new(options.max_memory_permits));
    
    // Process files as a stream with bounded concurrency
    let results = stream::iter(manifest.files())
        .map(|file| {
            let sem = memory_semaphore.clone();
            let cache = data_cache;
            async move {
                // Acquire memory permit (backpressure)
                let _permit = sem.acquire().await?;
                
                // Hash on blocking thread (CPU-bound)
                let (hash, data) = tokio::task::spawn_blocking(move || {
                    hash_file_contents(&file.path)
                }).await??;
                
                // Upload (I/O-bound, native async)
                cache.put_object(&hash, file.algorithm, &data).await?;
                
                Ok::<_, StorageError>(file.with_hash(hash))
            }
        })
        .buffer_unordered(options.concurrency)
        .collect::<Vec<_>>()
        .await;
    
    // Collect results and build updated manifest
    // ...
}

#[derive(Debug, Clone)]
pub struct HashUploadOptions {
    /// Max concurrent hash+upload operations
    pub concurrency: usize,  // Default: 10
    /// Max memory permits (each file holds one while in-flight)
    pub max_memory_permits: usize,  // Default: 20
}
```

### 4.4 Decision

**Do NOT implement Python's explicit two-pool pipeline.** Instead:
- Use `tokio::task::spawn_blocking` for CPU-bound hashing
- Use `buffer_unordered` for concurrent uploads
- Use `Semaphore` for memory backpressure
- This is simpler, more idiomatic, and equally efficient

---

## 5. SymlinkPolicy Alignment

### 5.1 Python Design

```python
class SymlinkPolicy(Enum):
    COLLAPSE_ESCAPING = auto()      # Preserve internal, collapse escaping (default)
    COLLAPSE_ALL = auto()           # Follow all symlinks
    PRESERVE = auto()               # Keep all symlinks with absolute targets
    TRANSITIVE_INCLUDE_TARGETS = auto()  # Keep symlinks and add targets
    EXCLUDE_ALL = auto()            # Skip all symlinks
    EXCLUDE_ESCAPING = auto()       # Preserve internal, exclude escaping
```

### 5.2 Current Rust Design

```rust
// crates/filesystem/src/scanner.rs
pub struct SnapshotOptions {
    pub follow_symlinks: bool,  // Only binary option
    // ...
}
```

### 5.3 Proposed Rust Design

```rust
// crates/filesystem/src/symlink.rs (UPDATE)

/// Policy for handling symlinks during manifest collection.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub enum SymlinkPolicy {
    /// Preserve internal symlinks, collapse escaping ones to their targets.
    /// This is the default and safest option for job attachments.
    #[default]
    CollapseEscaping,
    
    /// Follow all symlinks as if they were regular files/directories.
    CollapseAll,
    
    /// Preserve all symlinks with absolute targets.
    /// Warning: May create non-portable manifests.
    Preserve,
    
    /// Keep symlinks and transitively include their targets.
    /// Useful for ensuring all referenced content is captured.
    TransitiveIncludeTargets,
    
    /// Skip all symlinks entirely.
    ExcludeAll,
    
    /// Preserve internal symlinks, exclude escaping ones.
    ExcludeEscaping,
}

impl SymlinkPolicy {
    /// Check if a symlink should be followed (collapsed to target).
    pub fn should_follow(&self, is_escaping: bool) -> bool {
        match self {
            Self::CollapseAll => true,
            Self::CollapseEscaping => is_escaping,
            _ => false,
        }
    }
    
    /// Check if a symlink should be excluded.
    pub fn should_exclude(&self, is_escaping: bool) -> bool {
        match self {
            Self::ExcludeAll => true,
            Self::ExcludeEscaping => is_escaping,
            _ => false,
        }
    }
    
    /// Check if a symlink should be preserved as-is.
    pub fn should_preserve(&self, is_escaping: bool) -> bool {
        match self {
            Self::Preserve | Self::TransitiveIncludeTargets => true,
            Self::CollapseEscaping | Self::ExcludeEscaping => !is_escaping,
            _ => false,
        }
    }
}
```

---

## 6. Missing Operations Implementation

### 6.1 FILTER Operation

```rust
// crates/model/src/operations/filter.rs (NEW)

/// Filter manifest entries using a predicate.
/// 
/// # Arguments
/// * `manifest` - Any manifest type
/// * `predicate` - Function returning true for entries to keep
/// 
/// # Returns
/// Filtered manifest of the same type.
pub fn filter_manifest<M, F>(manifest: M, predicate: F) -> M
where
    M: ManifestOps,
    F: Fn(&ManifestFilePath) -> bool,
{
    // Implementation
}

/// Include/exclude filter based on glob patterns.
#[derive(Debug, Clone)]
pub struct IncludeExcludePathsFilter {
    include_patterns: Vec<Pattern>,
    exclude_patterns: Vec<Pattern>,
}

impl IncludeExcludePathsFilter {
    pub fn new(include: Vec<String>, exclude: Vec<String>) -> Result<Self, GlobError> {
        // Implementation
    }
    
    pub fn matches(&self, path: &str) -> bool {
        // Implementation
    }
}
```

### 6.2 COMPOSE Operation

```rust
// crates/model/src/operations/compose.rs (NEW)

/// Compose multiple manifests using trie-based merging.
/// 
/// Later manifests override earlier ones. Deletion markers are applied.
/// 
/// # Arguments
/// * `manifests` - Manifests to compose (order matters: later wins)
/// 
/// # Returns
/// Composed manifest.
pub fn compose_manifests<M: ManifestOps>(manifests: &[M]) -> M {
    // Use trie structure for efficient composition
    // Handle deletion markers properly
}

/// Internal trie node for manifest composition.
struct ManifestTrieNode {
    children: HashMap<String, ManifestTrieNode>,
    file_entry: Option<ManifestFilePath>,
    dir_entry: Option<ManifestDirectoryPath>,
    deleted: bool,
}
```

### 6.3 SUBTREE Operation

```rust
// crates/model/src/operations/subtree.rs (NEW)

/// Extract a subtree from a manifest as a relative-path manifest.
/// 
/// # Arguments
/// * `manifest` - Source manifest (any type)
/// * `subtree` - Path prefix to extract
/// * `symlink_policy` - How to handle symlinks crossing the boundary
/// 
/// # Returns
/// Relative-path manifest containing only entries under subtree.
pub fn subtree_manifest<M: ManifestOps>(
    manifest: &M,
    subtree: &str,
    symlink_policy: SymlinkPolicy,
) -> RelManifest {
    // Implementation
}
```

### 6.4 PARTITION Operation

```rust
// crates/model/src/operations/partition.rs (NEW)

/// Partition a manifest into multiple (root, RelManifest) pairs.
/// 
/// # Arguments
/// * `manifest` - Source manifest
/// * `roots` - Optional explicit roots (auto-detected if None)
/// * `referenced_paths` - Optional paths that must be included
/// * `symlink_policy` - How to handle symlinks
/// 
/// # Returns
/// List of (root_path, relative_manifest) tuples.
pub fn partition_manifest<M: ManifestOps>(
    manifest: &M,
    roots: Option<&[String]>,
    referenced_paths: Option<&[String]>,
    symlink_policy: SymlinkPolicy,
) -> Vec<(String, RelManifest)> {
    // Auto-detect roots if not provided:
    // - POSIX: longest common prefix
    // - Windows: one root per drive letter
}
```

### 6.5 JOIN Operation

```rust
// crates/model/src/operations/join.rs (NEW)

/// Prepend a prefix to all paths in a manifest.
/// 
/// Inverse of SUBTREE operation.
/// 
/// # Arguments
/// * `manifest` - Relative-path manifest
/// * `prefix` - Path prefix to prepend
/// 
/// # Returns
/// Manifest with prefixed paths (absolute if prefix is absolute).
pub fn join_manifest(manifest: RelManifest, prefix: &str) -> AnyManifest {
    // Implementation
}
```

---

## 7. Conflicts and Fundamental Approach Differences

### 7.1 No Fundamental Conflicts

The core rusty-attachments design is compatible with the Python Snapshots approach:

| Aspect | Python | Rust | Compatible? |
|--------|--------|------|-------------|
| Manifest versioning | Spec version strings | Enum variants | ✅ Yes |
| Path normalization | POSIX always | POSIX always | ✅ Yes |
| Hash algorithm | xxh128 | xxh128 | ✅ Yes |
| Chunking | 256MB | 256MB | ✅ Yes |
| Async I/O | asyncio | tokio | ✅ Yes |
| Memory management | GC + MemoryPool | Ownership + Semaphore | ✅ Yes |

### 7.2 Minor Differences to Address

1. **Error Handling**: Python uses exceptions; Rust uses `Result<T, E>`. The Rust approach is more explicit and aligns with the steering guidelines.

2. **Progress Callbacks**: Python uses `Callable[[Any], None]`; Rust uses `trait ProgressCallback<T>`. The Rust approach is more type-safe.

3. **Type Aliases**: Python uses `Union[...]`; Rust should use `enum` or `Either` types for better exhaustiveness checking.

### 7.3 Rust-Specific Enhancements

The Rust implementation can improve on Python in several areas:

1. **Compile-time path validation**: Use newtype wrappers to enforce abs/rel at compile time
2. **Zero-copy parsing**: Use `serde` with borrowed strings where possible
3. **Parallel hashing**: Use `rayon` for CPU-bound hashing with work-stealing
4. **Memory efficiency**: Use `bytes::Bytes` for zero-copy chunk handling

---

## 8. Deprecated Code Cleanup

### 8.1 Files to Remove/Rename

| Current File | Action | Reason |
|--------------|--------|--------|
| `model/src/v2025_12_04.rs` | **RENAME** to `v2025_12.rs` | Version name changed |

### 8.2 Code to Remove

| File | Item | Reason |
|------|------|--------|
| `model/src/lib.rs` | `V2025_12_04_beta` enum variant | **REMOVED FROM PYTHON** - replaced by `V2025_12` |
| `model/src/version.rs` | `V2025_12_04_beta` in `ManifestVersion` | No longer exists in Python |
| `model/src/encode.rs` | `"2025-12-04-beta"` spec string | Replaced by 4 new spec strings |
| `model/src/decode.rs` | `"2025-12-04-beta"` parsing | Replaced by 4 new spec strings |
| `model/src/merge.rs` | `merge_v2023_manifests()` helper | Superseded by `compose_manifests()` |
| `filesystem/src/diff.rs` | `DiffEngine` (partial) | Keep filesystem→manifest diff, add manifest→manifest |
| `storage/src/upload.rs` | Pre-hash assumption | Refactor to support unhashed manifests |

### 8.3 Code to Add

| File | Item | Description |
|------|------|-------------|
| `model/src/version.rs` | `PathStyle` enum | `Absolute` / `Relative` |
| `model/src/version.rs` | `SpecVersion` struct | Combined path-style + manifest-type |
| `model/src/manifest_types.rs` | **NEW FILE** | `Snapshot`, `SnapshotDiff`, `AbsSnapshot`, `AbsSnapshotDiff` wrappers |
| `model/src/operations/` | **NEW MODULE** | Composable operations |

### 8.4 Code to Refactor

| File | Item | Change |
|------|------|--------|
| `model/src/lib.rs` | `Manifest` enum | Change `V2025_12_04_beta(...)` to `V2025_12 { manifest, spec }` |
| `model/src/encode.rs` | Spec version encoding | Use `SpecVersion::spec_string()` |
| `model/src/decode.rs` | Version detection | Parse 4 new spec version strings via `SpecVersion::from_spec_string()` |
| `filesystem/src/scanner.rs` | `SnapshotOptions` | Add `SymlinkPolicy` field, remove `follow_symlinks: bool` |
| `filesystem/src/scanner.rs` | `snapshot()` | Split into `collect()` + `hash()` |
| `storage/src/types.rs` | `S3Location` | Align with `ContentAddressedDataCache` |
| `storage/src/manifest_storage.rs` | Content-Type headers | Use new spec version strings |

### 8.5 Migration Checklist

```
[ ] 1. Rename v2025_12_04.rs → v2025_12.rs
[ ] 2. Add PathStyle, SpecVersion to version.rs
[ ] 3. Update ManifestVersion enum (remove V2025_12_04_beta, add V2025_12)
[ ] 4. Update Manifest enum to include SpecVersion
[ ] 5. Create manifest_types.rs with newtype wrappers
[ ] 6. Update encode.rs to use new spec strings
[ ] 7. Update decode.rs to parse new spec strings
[ ] 8. Update all tests referencing V2025_12_04_beta
[ ] 9. Update storage content-type headers
[ ] 10. Run full test suite
```

---

## 9. Implementation Plan

### Phase 1: Model Updates
- Remove `V2025_12_04_beta`, add `V2025_12` with `SpecVersion`
- Rename `v2025_12_04.rs` → `v2025_12.rs`
- Add `PathStyle`, `SpecVersion` to `version.rs`
- Create `manifest_types.rs` with newtype wrappers
- Update encode/decode for new spec strings
- Update all tests

### Phase 2: Operations Module
- Create `crates/model/src/operations/` module
- Implement `collect_manifest()` (extract from scanner)
- Implement `hash_manifest()` (standalone)
- Implement `filter_manifest()` with `IncludeExcludePathsFilter`
- Implement `compute_diff_manifest()` (manifest→manifest)
- Implement `compose_manifests()` with trie
- Implement `subtree_manifest()`
- Implement `partition_manifest()`
- Implement `join_manifest()`

### Phase 3: Storage Updates
- Add `ContentAddressedDataCache` trait
- Add `FileSystemDataCache` implementation
- Rename `UploadOrchestrator` methods to `hash_upload_manifest()`
- Rename `DownloadOrchestrator` methods to `download_manifest()`
- Update to accept unhashed manifests

### Phase 4: Filesystem Updates
- Add `SymlinkPolicy` enum (6 variants)
- Update `SnapshotOptions` to use `SymlinkPolicy`
- Rename `snapshot_structure()` → `collect_manifest()`

### Phase 5: Cleanup
- Remove deprecated code paths
- Update all documentation
- Integration tests

---

## 10. Testing Strategy

### 10.1 Unit Tests

Each operation should have comprehensive unit tests:

```rust
#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_collect_manifest_basic() {
        // Test basic directory collection
    }
    
    #[test]
    fn test_collect_manifest_symlink_policies() {
        // Test each SymlinkPolicy variant
    }
    
    #[test]
    fn test_compose_manifests_deletion_markers() {
        // Test that deletions are applied correctly
    }
    
    #[test]
    fn test_partition_auto_detect_roots() {
        // Test automatic root detection
    }
    
    #[test]
    fn test_subtree_join_roundtrip() {
        // subtree(join(m, prefix), prefix) == m
    }
}
```

### 10.2 Integration Tests

```rust
// tests/integration/composable_operations.rs

#[tokio::test]
async fn test_job_submission_workflow() {
    // COLLECT → HASH_UPLOAD → PARTITION
}

#[tokio::test]
async fn test_output_download_workflow() {
    // JOIN → COMPOSE → DOWNLOAD
}

#[tokio::test]
async fn test_incremental_sync_workflow() {
    // COLLECT → HASH → DIFF → HASH_UPLOAD
}
```

### 10.3 Compatibility Tests

Ensure manifests created by Rust can be read by Python and vice versa:

```rust
#[test]
fn test_python_manifest_compatibility() {
    // Parse manifests generated by Python implementation
    // Verify all fields are correctly interpreted
}
```

---

## 11. Open Questions

1. **Should we support v2023-03-03 in new operations?**
   - Recommendation: No, return `VersionNotCompatibleError` per steering guidelines

2. **Should `ContentAddressedDataCache` be sync or async?**
   - Recommendation: Async, with sync wrappers for `FileSystemDataCache`

3. **Should we use `rayon` for parallel hashing?**
   - Recommendation: Use `tokio::task::spawn_blocking` for simplicity; `rayon` optional for batch scenarios

---

## 12. References

- [Python Snapshots API Summary](./2026-01-10.md)
- [Current Model Design](../model-design.md)
- [Current Storage Design](../storage-design.md)
- [Design Steering Guidelines](../../.kiro/steering/design-steering.md)
- [Coding Style Guidelines](../../.kiro/steering/coding-style.md)
